// Utility functions for SnappyDictWizard calculations

export const calculateResolution = (config) => {
  const { 
    base_cell_size, 
    surface_refinement_max, 
    first_layer_height, 
    resolution_strategy 
  } = config;

  // Calculate current volume cell size at the wall
  let localCellSize = base_cell_size / (2 ** surface_refinement_max);
  let gapRatio = localCellSize / first_layer_height;
  
  let strategyApplied = false;
  let strategyMessage = '';
  let adjustedConfig = { ...config };

  // Check if resolution is insufficient
  if (gapRatio > 400) {
    strategyApplied = true;
    const desiredLocalCell = first_layer_height * 100;
    
    if (resolution_strategy === "increase_levels") {
      // Calculate needed refinement level
      const neededLevelFloat = Math.log2(base_cell_size / desiredLocalCell);
      const neededLevel = Math.ceil(neededLevelFloat);
      
      adjustedConfig.surface_refinement_max = neededLevel;
      if (adjustedConfig.surface_refinement_min < neededLevel - 1) {
        adjustedConfig.surface_refinement_min = neededLevel - 1;
      }
      
      localCellSize = base_cell_size / (2 ** neededLevel);
      strategyMessage = `Increased refinement level to ${neededLevel}`;
      
    } else if (resolution_strategy === "refine_base") {
      // Calculate needed base mesh size
      const neededBase = desiredLocalCell * (2 ** surface_refinement_max);
      
      adjustedConfig.base_cell_size = neededBase;
      localCellSize = neededBase / (2 ** surface_refinement_max);
      strategyMessage = `Adjusted base cell size to ${neededBase.toFixed(5)} m`;
      
    } else if (resolution_strategy === "ignore") {
      strategyMessage = 'Warning: Gap ratio exceeds 400x - mesh quality may be poor';
      
    } else { // "abort"
      strategyMessage = 'Resolution conflict detected. Please adjust settings.';
    }
    
    // Recalculate gap ratio with potentially adjusted values
    gapRatio = localCellSize / first_layer_height;
  }

  return {
    gapRatio,
    localCellSize,
    strategyApplied,
    strategyMessage,
    adjustedConfig
  };
};

export const calculateLayerStack = (resolutionResults) => {
  const { localCellSize } = resolutionResults;
  
  // Use default or passed parameters
  const firstLayerHeight = resolutionResults.adjustedConfig?.first_layer_height || 0.001;
  
  const targetLastLayer = 0.7 * localCellSize;
  let bestN = 3;
  let bestRatio = 1.2;
  let found = false;
  
  // Search for healthy parameters
  for (let n = 3; n <= 20; n++) {
    const reqRatio = Math.pow(targetLastLayer / firstLayerHeight, 1.0 / (n - 1));
    if (1.05 <= reqRatio && reqRatio <= 1.35) {
      bestN = n;
      bestRatio = reqRatio;
      found = true;
      break;
    }
  }
  
  if (!found) {
    bestN = 20;
    bestRatio = Math.pow(targetLastLayer / firstLayerHeight, 1.0 / 19);
  }
  
  const finalLayerThickness = firstLayerHeight * Math.pow(bestRatio, bestN - 1);
  
  return {
    nSurfaceLayers: bestN,
    expansionRatio: bestRatio,
    finalLayerThickness,
    targetLastLayer
  };
};

export const generateDictContent = (config, resolution, layers) => {
  const { 
    geometry_name, 
    filename, 
    base_cell_size 
  } = config;
  
  const locationInMesh = base_cell_size * 0.5;
  
  return `/*--------------------------------*- C++ -*----------------------------------*\\
| =========                 |                                                 |
| \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\\\    /   O peration     | Version:  v2012+                                |
|   \\\\  /    A nd           | Website:  www.openfoam.com                      |
|    \\\\/     M anipulation  |                                                 |
\\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      snappyHexMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// Generated by SnappyDictWizard
// Target y+ Height: ${config.first_layer_height} m
// Base Mesh Size:   ${base_cell_size} m
// Gap Ratio:        ${(resolution.localCellSize / config.first_layer_height).toFixed(1)}

castellatedMesh true;
snap            true;
addLayers       true;

geometry
{
    ${geometry_name}
    {
        type triSurfaceMesh;
        file "${filename}";
    }
};

castellatedMeshControls
{
    maxLocalCells 1000000;
    maxGlobalCells 2000000;
    minRefinementCells 10;
    maxLoadUnbalance 0.10;
    nCellsBetweenLevels 3;

    features
    (
        {
            file "${geometry_name}.eMesh";
            level ${config.surface_refinement_max};
        }
    );

    refinementSurfaces
    {
        ${geometry_name}
        {
            level (${config.surface_refinement_min} ${config.surface_refinement_max});
        }
    }

    resolveFeatureAngle 30;
    refinementRegions
    {
    }

    locationInMesh (${locationInMesh} ${locationInMesh} ${locationInMesh}); // CHECK THIS COORDINATE
    allowFreeStandingZoneFaces true;
}

snapControls
{
    nSmoothPatch 3;
    tolerance 2.0;
    nSolveIter 30;
    nRelaxIter 5;
    nFeatureSnapIter 10;
    implicitFeatureSnap false;
    explicitFeatureSnap true;
    multiRegionFeatureSnap false;
}

addLayersControls
{
    relativeSizes false; // Using absolute meters
    
    layers
    {
        ${geometry_name}
        {
            nSurfaceLayers ${layers.nSurfaceLayers};
        }
    }

    // Calculated Settings
    expansionRatio ${layers.expansionRatio.toFixed(4)};
    finalLayerThickness ${layers.finalLayerThickness.toFixed(8)};
    minThickness ${(config.first_layer_height / 1.5).toFixed(8)};
    
    // Quality Controls
    nGrow 0;
    featureAngle 60;
    slipFeatureAngle 30;
    nRelaxIter 3;
    nSmoothSurfaceNormals 1;
    nSmoothNormals 3;
    nSmoothThickness 10;
    maxFaceThicknessRatio 0.5;
    maxThicknessToMedialRatio 0.3;
    minMedianAxisAngle 90;
    nBufferCellsNoExtrude 0;
    nLayerIter 50;
}

meshQualityControls
{
    #include "meshQualityDict"
}

mergeTolerance 1e-6;

// ************************************************************************* //`;
};